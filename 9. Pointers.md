[Previous: Algorithms using Arrays]()

# Pointers in C++

Before starting with the different usage of pointers, lets see first that why we actually need it. 

Consider the program below:

```
#include<iostream>
using namespace std;

void ChangeAandB(int x, int y);

int main()
{
	int a = 5, b = 15;

	ChangeAandB(a,b);
	cout << a << ", " << b << endl;
	return 0;
}

void ChangeAandB(int x, int y)
{
	x = 100;
	y = 200;
	cout << x << ", " << y << endl;
}

```

The above function ChangeAandB(int, int) is trying to change the values of the variables but that change is not reflected back to the main function. Moreover, the function can't also return more than one value at a time. This setting of passing the values to a function is called **"Pass a value"**, where the values of the variable are passed from the calling function and the receiving function creates new variables to receive those values. These values are just the copy of the variables present in the calling function. Any changes made to those copies inside the called function are discarded once the control of the compiler goes back to the calling function.

This problem can be overcome by using the pointers. So, let's see what is a pointer:

```
#include<iostream>
using namespace std;

int main3()
{
	int x = 5;
	int* y; // A Pointer y which will point to the variable of type integer
	y = &x; // Pointer is pointing to the address of variable x

	cout << "Value of x = " << x << endl; // prints the value of x 
	cout << "Address of x / value of y =" << y << endl; // Prints the address pointed by y (Address of x)
	cout << "Value of memory location pointed by y = " << *y << endl; // prints the value of variable pointed by y
	cout << "Address of y = " << &y << endl; // prints t he address of y
	return 0;
}
```
Let's use the pointer to modify the problem where a function wants to alter the value of the variable present in the calling function using pointer:

```
#include<iostream>
using namespace std;

void ChangeA(int* p);

int main()
{
	int a = 5;
	int* p;// Declaration of Pointer => to store the address of a memory location

	p = &a; // Address of a is assigned to p
	ChangeA(p); // Pass by address
	cout << a << endl;
	return 0;
}

void ChangeA(int* p) 
{
	*p = 100;
}
```

Now let's see how we can make use of pointers to change the values of variables of calling function inside the function being called. We will understand the use of pointers using our classic Swap function. The main function will have two variables, and then a function Swap(int, int) is being called to swap the values of those variables using pointer. We will see that the values of the variables will actually got changed once the control of the compiler returns back to the calling funtion (i.e., main function):

```
#include<iostream>
using namespace std;

void Swap(int* a, int* b);
int main()
{
	int a = 5, b = 10;
	Swap(&a, &b); // Passing the values of a and b by reference
	cout << "a = " << a << ", b =" << b << endl;
	return 0;
}

void Swap(int* a, int* b)
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
	cout << "*a = " << *a << ", *b =" << *b << endl;
}
```

## Pointer to store String Constant

There is a special use of pointer where a string constant can be stored in the pointer, without using any array:

```
#include<iostream>
using namespace std;

int main()
{
	const char* err404;
	err404 = "This is an error message 404";

	cout << err404 << endl;
	return 0;
}
```
## Use of pointer to perform intersection operation of sets

Assume we have two sets of integers stored in two arrays say a and b. We will perform the set operation *Intersection* between the two given sets. We will call a function name Intersection which will recieve the base address of the two arrays as arguments and their respective lengths and prints the set "a intersection b".

```
#include<iostream>
using namespace std;
void Intersection(int* a, int* b, int la, int lb);
int main()
{
	int A[] = { 2, -3, 7, 8, 2, 14};
	int B[] = { 1, 8, 15, 2};
	int lenA = sizeof(A)/sizeof(A[0]);
	int lenB = sizeof(B) / sizeof(B[0]);
	Intersection(A, B, lenA, lenB);

}

bool CheckedBefore(int* a, int ind)
{
	for (int i = 0; i < ind; i++)
	{
		if (a[ind] == a[i])
			return true;
	}
	return false;
}

void Intersection(int* a, int* b, int la, int lb)
{
	for (int i = 0; i < la; i++)
	{
		if (CheckedBefore(a, i) == true)
		{
			continue;
		}
		for (int j = 0; j < lb; j++)
		{
			if (a[i] == b[j]) // (baseADdress + (index# * Size of datatype))
			{
				cout << a[i] << ", ";
			}
		}
	}
}
```

## Pointer to Pointer

We can also create a pointer which points to a pointer. This phenomenenon is called Pointer to pointer. Lets see:

```
#include<iostream>
using namespace std;

int main()
{
	int x = 5;
	int* px = &x;
	int** ppx = &px;
	
	cout << **ppx << endl;
	return 0;
}
```

Here ppx is a pointer which pointers to a pointer px and px is a pointer which points to integer variable x. You can create as long chain of pointer pointing pointer as you want.


# Variable Alias

An incredibly useful way of dealing with variables among functions is by using varibale alias. A variable alias 'x' of variable 'a' can be created using the following pair of statements:

** int a;
int &x = a;**

Variable alias is just another name given to any variable. In the above case, there is a variable 'a' and we have given just another name 'x' to 'a'. Observe another progaram and try to understand variable alias:

```
double d = 31.564;
double& anotherd = d;
double& yetAnotherD = anotherd;
cout << &d << ", " << &anotherd << ", " << &yetAnotherD << endl;
```

Now, lets observe some incredibly interesting features of the variable alias by using the program below:

```
#include<iostream>
using namespace std;

int main()
{
	int x = 15;
	int& refX = x; // Reference or alias to x

	cout << x << endl;
	cout << refX << endl; // Value same as x

	cout << sizeof(x) << endl;
	cout << sizeof(refX) << endl; // Size same as x

	cout << &x << endl;
	cout << &refX << endl; // because address is same as x
	return 0;
}
```

Why we need to variable alias at all? Because variable alias reduces the complexity of programs. Let's review our classic swapping problem using variable alias and try to understand the difference:

```
#include<iostream>
using namespace std;

void Swap(int& x, int& y);

int main()
{
	int a = 5, b = 10;

	Swap(a, b);
	cout << "a = " << a << ", b = " << b << endl;
	return 0;
}

void Swap(int& x, int& y)
{
	int tmp;
	tmp = x;
	x = y;
	y = tmp;
}
```



[Next: Multi-dimensional Array]()
